<html>
<body>
<div class="UntypedBox__Wrapper-sc-4e7tnk-0 hZvgth Floater-vcx7dh-0 fDxnkS task-description__ThemedBox-sc-380ibo-0 fODIgU"><div style="height: 100%; position: relative;"><div id="standard_task_description" class="protected" tabindex="0" style="height: 100%; overflow: auto;"><div class="task-description__TaskContentWrapper-sc-380ibo-1 xtrBv task-description-content">

<meta http-equiv="content-type" content="text/html; charset=utf-8">


<div class="brinza-task-description">
<p>Strings with long blocks of repeating characters take much less space if kept in a compressed representation. To obtain the compressed representation, we replace each segment of equal characters in the string with the number of characters in the segment followed by the character (for example, we replace segment "CCCC" with "4C"). To avoid increasing the size, we leave the one-letter segments unchanged (the compressed representation of "BC" is the same string − "BC").</p>
<p>For example, the compressed representation of the string "ABBBCCDDCCC" is "A3B2C2D3C", and the compressed representation of the string "AAAAAAAAAAABXXAAAAAAAAAA" is "11AB2X10A".</p>
<p><img class="inline-description-image" src="https://codility-frontend-prod.s3.amazonaws.com/media/task_static/lossy_compression/static/images/auto/df179f2c1be7e666891060da097377a8.png" alt="Image illustrating compression of string &quot;ABBBCCDDCCC&quot;"></p>
<p><img class="inline-description-image" src="https://codility-frontend-prod.s3.amazonaws.com/media/task_static/lossy_compression/static/images/auto/64f819f92142f80dd932313867f7ceff.png" alt="Image illustrating compression of string &quot;AAAAAAAAAAABXXAAAAAAAAAA&quot;"></p>
<p>Observe that, in the second example, if we removed the "BXX" segment from the middle of the word, we would obtain a much shorter compressed representation − "21A". In order to take advantage of this observation, we decided to modify our compression algorithm. Now, before compression, we remove exactly K consecutive letters from the input string. We would like to know the shortest compressed form that we can generate this way.</p>
<p>Write a function:</p>
<blockquote><p style="font-family: monospace; font-size: 9pt; display: block; white-space: pre-wrap"><tt>function solution(S, K);</tt></p></blockquote>
<p>that, given a string S of length N and an integer K, returns the shortest possible length of the compressed representation of S after removing exactly K consecutive characters from S.</p>
<p><b><b>Examples:</b></b></p>
<p>1. Given S = "ABBBCCDDCCC" and K = 3, the function should return 5, because after removing "DDC" from S, we are left with "ABBBCCCC", which compresses to a representation of length 5 − "A3B4C".</p>
<p><img class="inline-description-image" src="https://codility-frontend-prod.s3.amazonaws.com/media/task_static/lossy_compression/static/images/auto/3be824cd5947c06e6e76846b82c8f3a4.png" alt="Image illustrating compression of string &quot;ABBBCCDDCCC&quot; with deletion of K = 3 consecutive letters"></p>
<p>2. Given S = "AAAAAAAAAAABXXAAAAAAAAAA" and K = 3, the function should return 3, because after removing "BXX" from S, we are left with "AAAAAAAAAAAAAAAAAAAAA", which compresses to a representation of length 3 − "21A".</p>
<p><img class="inline-description-image" src="https://codility-frontend-prod.s3.amazonaws.com/media/task_static/lossy_compression/static/images/auto/4f9cde8921ed031e67d2dc95fbaa100f.png" alt="Image illustrating compression of string &quot;AAAAAAAAAAABXXAAAAAAAAAA&quot; with deletion of K = 3 consecutive letters"></p>
<p>3. Given S = "ABCDDDEFG" and K = 2, the function should return 6, because after removing "EF" from S, we are left with "ABCDDDG", which compresses to a representation of length 6 − "ABC3DG".</p>
<p><img class="inline-description-image" src="https://codility-frontend-prod.s3.amazonaws.com/media/task_static/lossy_compression/static/images/auto/33a633b02e38cb15abbf9abf863e339e.png" alt="Image illustrating compression of string &quot;ABCDDDEFG&quot; with deletion of K = 2 consecutive letters"></p>
<p>Write an <b><b>efficient</b></b> algorithm for the following assumptions:</p>
<blockquote><ul style="margin: 10px;padding: 0px;"><li>N is an integer within the range [<span class="number">1</span>..<span class="number">100,000</span>];</li>
<li>K is an integer within the range [<span class="number">0</span>..<span class="number">100,000</span>];</li>
<li>K ≤ N;</li>
<li>string S consists only of uppercase letters (<tt style="white-space:pre-wrap">A</tt>−<tt style="white-space:pre-wrap">Z</tt>).</li>
</ul>
</blockquote></div>
<div style="margin-top:5px">
<small>Copyright 2009–2020 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.</small>
</div>

</div></div></div></div>
</body>
</html>